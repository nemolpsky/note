## BIO与NIO

BIO是Blocking I/O的简称，也就是同步阻塞的I/O模式，是JDK1.4版本以前的主要操作I/O的方式，NIO全称New IO，也叫Non-Block IO，是一种非阻塞同步的通信模式。


---

### BIO

![BIO](https://github.com/nemolpsky/note/raw/master/file/io/image/io1.png)

BIO是同步阻塞的，比如在网络连接中使用BIO模式，需要先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信，也就是一请求一应答模式，如果当前线程已经有一个耗时的IO操作正在进行那么其他所有的请求和操作都会被阻塞朱，所以一般情况下会使用多线程进行优化，每次请求过来就开启一个子线程或者是放入线程池中，这样也算是解决了高并发阻塞问题，但是这样也会给服务器带来很大的负担，线程数量很大的话会造成很大的性能消耗的。

在Java中传统的阻塞IO大概分为下面四类

- InputStream、OutputStream，基于字节操作的IO
- Writer、Reader，基于字符操作的IO
- File，基于磁盘操作的IO
- Socket，基于网络操作的IO



### NIO

![NIO](https://github.com/nemolpsky/note/raw/master/file/io/image/io2.png)

NIO是non-blocking I/O的简称，是对于BIO的一种改进，它是同步不阻塞的，主要就是为了解决高并发下BIO的各种问题。NIO是基于Reactor模式，也就是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers，这个Service Handler会同步的将输入的请求(Event)多路复用的分发给相应的Request Handler。其实就是请求过来之后会到一个多路复用器，它的作用可以理解为是一个专门轮询判断请求是否连接好，是否需要开始进行IO操作的东西，所以它不像BIO一过来就直接放到线程里面，一阻塞整个线程都阻塞住了，所以NIO很适合数量大，但是连接时间短的场景，它依靠多路复用器来判断哪个连接需要开始传输数据了，才开启线程执行IO操作，所以它可以单线程或者少量的线程来执行IO问题，对服务器的性能提高很好，但是如果并发量特别高的话，把有限数量的线程占满后还是会出现BIO那种阻塞情况。

在Java1.4开始引入了nio框架，里面都是关于NIO模式的引入的一些新的API，对应java.nio包，提供了Channel(通道)，Selector(选择器)，Buffer(缓冲区)等抽象实现，其中Selector就是对应的上面多路复用器的位置，通过它来判断有哪些Channel已经准备好写入或者写出了，它和BIO流的区别有下面四点。

1. IO流是阻塞的，NIO流是不阻塞的

   比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情，Java IO的各种流是阻塞的。这意味着，当一个线程调用read()或write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。

2. IO面向流，而NIO面向缓冲区

   Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中可以将数据直接写入或者将数据直接读到Stream对象中。虽然Stream中也有Buffer开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而NIO却是直接读到Buffer中进行操作。

   在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。

   最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能用于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，除了Boolean类型每一种Java基本类型都对应有一种缓冲区。

3. Channel

   NIO通过Channel(通道)进行读写。通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为Buffer，通道可以异步地读写。


4. Selector

   NIO有选择器，而IO没有。选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。