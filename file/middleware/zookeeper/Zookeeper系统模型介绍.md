## 一、Zookeeper系统模型
Zookeeper是一个保证强一致性的框架，用途非常广泛，尤其是在分布式系统中的应用。而它内部的系统模型设计则是保证它能够高效的实现这些功能的关键，因此了解它的内部模型设计还是很有必要的。

---

## 二、数据模型

#### 1.视图结构
Zookeeper中有着```数据节点```的概念，也就是ZNode，它是Zookeeper中的最小数据单位，每个ZNode中都可以保存数据，而且每个ZNode都可以拥有子节点。也就是说Zookeeper中的ZNode节点最终会是树的结构，而它的命名空间则和Unix文件系统很像，每个节点之间使用/来分割，就像目录一样，例如下图就是一个ZNode节点的树状结构图。

图

#### 2.事务ID
事务在数据库中是很常见的，它令数据库可以保证ACID特性，也保证了数据一致性的问题。而Zookeeper作为一个满足CAP理论中CP条件的分布式框架，自然也有着事务的概念来保证数据的一致性。一般对ZNode节点的任何变动操作，例如新增、修改和删除等等都会认为是一次事务操作。因此Zookeeper会为每个事务请求创建一个全局唯一的事务ID，也被称为ZXID，通常是一个64位的数字，Zookeeper就是利用事务ID来保证全局的事务请求的操作顺序。

---

## 三、ZNode节点类型
在Zookeeper中ZNode节点是有四种类型的，每种类型都有着不同的特性和生命周期。
- 持久节点(PERSISTENT)

  顾名思义，创建之后一直存在，除非手动删除这个节点。
- 持久顺序节点(PERSISTENT_SEQUENTIAL)

  在持久节点的基础上还能保持节点的下子节点创建的顺序，Zookeeper会给节点添加一个数字后缀来作为顺序，该数字上线是整型的最大值。
- 临时节点(EPHEMERAL)

  和持久节点相反，它的生命周期和客户端的会还绑定在一起，如果客户端的会话结束了，这个临时节点也就会被自动删除了。
- 临时顺序节点(EPHEMERAL_SEQUENTIAL)

  在临时节点的基础上保证了顺序，和持久顺序节点一个原理。

每个ZNode节点都有着自己的状态数据，存储在一个名为Stat对象中，使用get命令查看可以看到，下图列出了每项属性的含义，其中还包含了版本信息。

---

## 四、使用版本号配合乐观锁保证原子性操作。

Zookeeper能保证分布式系统操作数据时不发生并发问题，就是使用版本号配合乐观锁来实现的。

比如version是当前节点的版本号，只要对当前节点进行了变更操作version就会自增，要注意的是只要对节点进行了变更操作就会自增，那怕本次操作对ZNode节点数据没有造成任何变化。
而更新的方式则是使用CAS的方式，也就是每次操作都会对比版本号，对的上才能进行操作，表示没有并发问题，对不上则表示数据已经被人修改过了，也就不能修改ZNode节点的数据。

---

## 五、Watcher机制

在Zookeeper中有一套Watcher机制来实现了分布式的发布/订阅功能。

如下面这张图表示的，客户端可以监听多个主题，每当这个主题有变化的时候服务端则会通知客户端，客户端会向服务端注册一个Watcher监听，服务端则会通过这个Watcher监听来发送通知个客户端，客户端在注册了Watcher监听后还会把它存在本地的WatchManager中，这也表示客户端可以注册多个Watcher监听，每次收到通知则在WatchManager中取出对应的Watcher对象来执行回调逻辑，其实就是基于观察者模式的一种设计。

图

但是为了保证性能，尤其是考虑了分布式系统情况下各种可能发生的网络问题，Zookeeper中的Wathcer机制还是有一些需要特别注意的地方，在Watcher机制中所有的通知都是使用WatchedEvent对象来进行通知传递，而WatchedEvent中只包含了三部分内容，通知状态、事件类型和节点路径，但是并没有其它数据，所有Zookeeper中的Wathcer机制真的只起到了通知的作用，服务端会告诉客户端节点有变化，但是具体数据有什么变化需要客户端自己去查询节点。比如下图显示的就是Watcher通知的状态和类型。

图


Watcher机制的通知流转过程

- 客户端注册Watcher

  这一步客户端会创建一些Watcher对象用来保存节点的路径和Watcher之间的对应关系，但是为了性能考虑，并不会真正的发送这些对象给服务端，而是请求的时候带上一个标记，表示需要注册Watcher监听，而这些Watcher对象则会被存在客户端中的WatchManager中。

- 服务端注册Watcher

  服务端在接收到客户端的请求时会根据标记判断是否需要注册监听，如果需要监听则也会在服务端的WatchManager中注册这个请求监听的节点，这也和上面通知中质保函状态和事件类型相对应，服务端只知道客户端请求注册监听，但是具体要监听啥，服务端也不知道，但是监听对象有变化的时候就会通知客户端，客户端自己再去查询。

- 服务端触发回调

  当服务端发现有一个被监听的对象发生了变化，就会封装WatchedEvent对象发送通知给对应的客户端，同时这个Watcher监听也就会从服务端移除。

- 客户端执行回调

  客户端接收到了服务端的通知，就知道自己监听的对象发生了变化，这个时候客户端就可以自己再去查询这个节点中的数据了，并且也会把这个Watcher监听移除。


根据Watcher机制就会发现它有一些特点需要我们注意

- 一次性

  一旦注册的Watcher被触发了，它就会被服务端和客户端移除，这样是为了保证服务端不会因为注册太多的Watcher而带来性能问题，也就是说一个注册好的Watcher监听只能用一次。

- 客户端串行执行

  客户端接到通知会从WatchManager中取出对应的Watcher对象来执行回调，但是注意的是，回调的执行是串行的，也就是说如果有一个回调堵塞了会影响后续其他Watcher的所有回调。

- 轻量

  在Watcher机制中所有的通知都是使用WatchedEvent对象来进行通知传递，而WatchedEvent中只包含了三部分内容，通知状态、事件类型和节点路径，也就是说客户端只知道数据有了变化，但是具体怎么变化的则不知道，这样的目的是为了减少通知传递过程中的网络开销，性能更好，因此客户端还需要再自己去查询节点。

---

## 六、ACL机制
ACL的全称是Access Control List，是一种权限控制机制，Zookeeper就使用这种权限机制，它有以下四种权限模式。还有一个概念是授权对象，也就是说标识权限赋予的对象，换句话说就是如果节点之间拥有同一个授权对象，那标识他们处于相同的权限控制范围内。
- IP

  也就是通过IP来控制权限，授权对象一般是一个IP地址或IP段，例如192.168.1.25或192.168.0.1/24

- Digest

  通过用户名和账号来控制权限，授权对象是自定义的键值对，例如username:123或john:skdljflksdjfl

- World

  不控制权限，对外开放所有权限，授权对象是固定的anyone

- Super

  超级权限，可以操作Zookeeper上任意节点，授权对象和Digest是一样的。
  
在Zookeeper中总共有以下五种权限

- CREATE (C) 

  数据节点的创建权限,允许授权对象在该数据节点下创建子节点。
- DELETE (D) 

  子节点的删除权限,允许授权对象删除该数据节点的子节点。
- READ (R)
  
  数据节点的读取权限,允许授权对象访问该数据节点并读取其数据内容或子节点列表等。
- WRITE (W) 

  数据节点的更新权限,允许授权对象对该数据节点进行更新操作。
- ADMIN (A)

  数据节点的管理权限,允许授权对象对该数据节点进行ACL相关的设置操作。



