### Eureka内部数据结构

Eureka本质上就是维护一个注册表，并且在集群情况下来保证注册表的最终一致性，同时还要尽可能快的感知整个微服务群的中各个实例的状态变化，所以对注册表的设计就比较重要了，不然很难抗住高并发下的读写。

---


#### 1. 多级缓存

Eureka注册表的数据机构是三层结构的数据设计，最外层的是只读缓存，默认开启，由```ConcurrentHashMap```实现，它支持并发，性能比较好，客户端拉取注册表时最先由只读缓存内拉取。


读取缓存中没有就会读取下一层缓存，读写缓存，由```Google Guava```的```LoadingCache```实现，相比```ConcurrentMap```来说有废弃策略，在获取元素未命中时可以从其它数据源获取并更新到缓存中。


最后如果前两层缓存中都没有获取到数据就会直接查询注册表，所以正常情况下查询顺讯应该是下列这样的。

```
只读缓存 -> 读写缓存 -> 注册表
```


---

#### 2. 缓存间的同步

最新的数据肯定是来源于注册表，所以考虑的就是如何将注册表数据同步到其它两层缓存中，实时同步肯定不现实，例如10个实例，每个实例有100个服务，每30秒一次心跳检测，那每分钟就是10 * 100 * 2 = 2000次操作，所以Eureka是定时过期缓存中的数据加上一些条件触发同步操作。这种定时同步机制配合多级缓存是为了避免所有读写都直接对注册表进行操作，因为Eureka内部有很多同步操作还有心跳检测，将这些操作分散到不同的缓存可以避免高并发性能问题。

对于只读缓存来说，默认每隔30秒就会去同步读写缓存中的数据，而对于读写缓存来说数据有效时间为180秒，超过180秒就在注册表中拉取，这都属于定时过期。

此外每次有新的实例注册时都会主动触发读写缓存中的数据过期，但是对只读缓存中的数据不影响，所以读写缓存中的数据更新了，但是30秒后才能同步到只读缓存中，如果日常开发多注意就会发现有时候启动一个服务就调用会显示找不到该服务，可以在开发环境设置只读缓存的数据同步周期，把30秒的同步周期改的更短，或者禁用只读缓存直接使用度写缓存。


---

#### 3. 增量拉取注册表

前面说到每个客户端都会有一份注册表的本地缓存，只有在本地缓存为空时才直接全量拉取Eureka服务中的注册表，否则就是增量拉取，实现原理也很简单，Eureka服务中维护了一个队列存放最新注册的信息，所谓增量拉取就是只拉取这部分数据，然后客户端会进行合并。合并完之后Eureka会根据整个注册表来计算哈希值，然后对比客户端和Eureka服务两者之间注册表的哈希值，不一致的话就直接再触发一次全量拉取，流程就是下面这个样子。

![1](https://github.com/nemolpsky/note/raw/master/file/micro/eureka/images/2.png)
