### 一、Java内存区域
1. 程序计数器
   
   线程私有，通过计数器的值来控制下一条要执行的字节码指令，分支、循环和线程恢复等基础功能都依赖这个计数器。执行Java方法的时候计数器记录的是字节码指令的地址，如果是Native方法值为空。唯一一个不会出现OOM情况的区域。
2. Java虚拟机栈
   
   每个线程都会有一个虚拟机栈，其实可以理解为一个堆栈结构，存储的数据是栈帧，什么栈帧？可以理解为执行一个方法所需要的所有数据，比如方法的参数，局部变量还有方法的返回等等，其实这也就是常说的栈内存，存放基本类型数值和引用的地方，在帧栈深度大于虚拟机栈的时候就回抛出StackOverFlowError异常，而当虚拟机栈扩展时内存不足就会抛出OOM异常。
3. 本地方法栈
   
   跟Java虚拟机栈很像，只不过是专门给Native方法用的。在HotSpot虚拟机中和Java虚拟机栈是同一个。
4. Java堆
   
   也叫堆内存，线程共享，专门用来存放对象实例的，可以处于物理上不连续的空间，只要逻辑上连续即可，会抛出OOM异常。
5. 方法区(1.8中被元空间取代，元空间是存放在堆中)
   
   线程共享，存储被虚拟机加载的类信息、常量、静态变量和即时编译器，在HotSpot虚拟机中是用永久代(永久代是HotSpot虚拟机中对方法区的一种具体实现，专门用来当做方法区使用的一块被称作永久代的区域)来实现方法区，会抛出OOM异常。
6. 运行时常量池(1.7中移到了堆中存放)
   
   是方法区的一部分，用于存放编译时期生成的各种字面量和符号引用。运行时也能将新的常量放入池中，比如String.intern()方法，会抛出OOM异常。
7. 直接内存
   
   直接使用Native函数库直接分配堆外内存，能显著提高性能，避免了在Java堆和Native堆之间来回复制数据，会抛出OOM异常。

总结来看，可以粗略分为堆内存和栈内存，还有本地方法栈和计数器，方法区和常量池都已经合并到堆中了。

--- 

### 二、虚拟机中的对象
1. 虚拟机创建对象，一般是有两种方式。
   
   如果堆内存是完全规整的，比如说使用的内存在一边连在一起，不使用的在另一边，只需要中间的指针往空闲的内存那边移动与对象大小相同的距离，这被称为指针碰撞。
   
   如果不是规整的，使用和未使用的内存是混在一起的，就需要维护一个列表来记录哪些内存块是可用的，这被称为空闲列表。
2. 对象的内存布局
   
   对象头，第一部分存对象相关的信息，哈希码、锁状态和持有锁等信息。第二部分存对象的类型指针，用来判断对象的类型。如果是数组还会额外存数组的大小。
   
   实例数据，存对象中真正的数据，变量值、从父类继承的东西。
   
   对齐填充，HotSpot VM的自动内存管理系统要求对象起始地址必须是8倍整数，也就是对象的大小，所以不是8倍的话就补齐，仅此而已。
3. 对象的访问定位，有两种方式。
栈内存中有reference来保存对象的实例的地址。
   
   句柄访问，堆内存中有一个句柄池，句柄中存了对象的地址，优点是对象变动时只需要修改句柄中的信息。
   
   直接指针访问，reference直接存的对象地址，优点是省了一个步骤，查找更快。
   
---

### 三、判断对象是否被回收
1. 引用计数算法和可达性算法
   
   引用计数算法，只要对象被引用就计数器+1，失效就-1，为0的时候就可以被回收，但是无法解决相互引用问题，比如A引用B，B引用A，两个对象的计数器都是1，但是毫无意义。
   
   可达性算法，JVM虚拟机中就是使用这种方式，判断对象的引用能不能到达GC Roots，如果不能，就算被其他对象引用了也可以回收。
   
   GC-Roots的含义，2和3本质上就是final修饰的常量，1和4本质上就是正在执行的方法所引用到的对象。
   - 虚拟机栈(栈帧中的本地变量表)中引用的对象，也就是栈内存中引用对应的对象。
   - 方法区中静态属性引用的对象，
   - 方法区中常量引用的对象
   - 本地方法栈中引用的对象
2. 真实回收对象的时机

   理论上来说如果按照可达性算法不能够查找到GC Roots的话就会被回收，但是其实并不是。会先放到叫做F-Queue队列中，然后由虚拟机创建一个优先级很低的叫做Finalizer的线程来执行，这样是避免执行finalize()方法执行缓慢阻塞队列，甚至让内存回收系统崩溃。还要注意的是如果在F-Queue队列执行到对象前，对象如果重新被引用了，它就会被移除队列，避免被回收。finalize()方法并不可靠，就算拿来关闭外部资源也不适合，太多不确定性，所以应该避免使用这个方法。
3. 对方法区的回收

   因为在HotSpot虚拟机中对方法区的实现就是永久代，所以其实就是回收永久代，性价比较低，不如回收新生代回收的空间多(70%-95%)。主要是回收常量和类(静态类和动态加载的类)。
   
   - 常量，如果没有任何引用到就会被回收。
   - 类，所有实例被回收，类加载器也被回收，这个对象的java.lang.Class对象也没有被引用，被会被反射调用到。这三个条件满足就可以被回收，注意是可以，不是必然。

---

### 四、垃圾收集算法
1. 标记-清除(HotSpot虚拟机没有使用)
   
   把要清除的对象标记，特点是容易造成不连续的内存碎片，导致分配对象的时候更容易要进行垃圾收集的动作。
2. 复制算法(新生代使用，可以清理掉大量对象)
   
   把内存分为两块，当其中一块用完了，就把存活的复制到另一块，然后清空原来的那块。不会有内存碎片的情况，但是内存可用数量减半了，所以实际中HotSpot虚拟机虽然在新生代中使用了这种算法，但是是分为三块内存，Eden占80%，Survivor占10%而且有两块，每次存活的对象都会移到其中一块Survivor中。因为根据研究新生代98%的对象都会死掉，所以10%就足够了，只浪费10%还是可以接受的。当然实际也有可能这10%是不够用的，这时候就会使用老年代的内存空间来存放复制的对象。
3. 标记-整理(老年代使用)
   
   过程是和标记-清除很像，但是不同的是清理掉要回收的对象后，会让所有对象都往一端移动，解决内存碎片的问题。
4. 分代收集算法(其实就是2和3同时使用，HotSpot虚拟机也是)
   
   基本所有的商业虚拟机都用这种算法，根据对象的存活周期把内存划分为几块，一般时新生代和老年代，新生代这种回收率高的区域用复制算法，而老年代这种回收率低的则用标记-清除或者标记-整理。

---

### 五、HotSpot虚拟机回收操作的算法实现
1. 枚举根节点
   
   因为判断类是否回收就是判断是能到达GC Roots，而现在大型项目中内存里的引用数量非常多，如果逐个检查必定需要耗费时间，所以直接用叫做OopMap的数据结构等方法来直接获取所有引用的存放地址。
2. 安全点
   
   OopMap虽然可以快速完成GC Roots枚举，但是每个指令都会造成引用变化，如果每时每刻都保存OopMap数据的话内存消耗太大了。所以只在安全点来保存OopMap数据并进行GC，安全点会特意选在那些执行时间比较长的地方进行，比如调用方法，循环跳转和异常跳转。
   
   GC的时候会让所有的线程都到安全点再停下来，有抢先式中断和主动式中断。抢先式中断就是如果线程没有到达安全点就让它运行到安全点再停顿，主动式则是设置一个停止标记，每个线程如果轮询检查到标记是要停顿就会停顿，虚拟机基本都用的主动式中断。
3. 安全区域
   
   因为有时候线程可能会阻塞，无法到安全点，这个时候也不能等待它，就要设置安全区域，就是一段引用关系不会边的代码中。在这里面即使有线程没有到达安全点，GC也是安全的。

---
 
### 六、内存分配和回收策略
1. 对象会优先分到新生代中的Eden区，内存不够则进行一次Minor GC，设置-XX:+PrintGCDetails来打印收集器日志。
2. 大对象直接分配到老年代，设置-XX:PretenureSizeThreshold来设置超过多大的对象直接进入老年代。
3. 长期存活的对象也会进入到老年代，每个对象都有一个年龄计数器，每Minor GC一次不回收就加一岁，默认超过```15岁```就进入老年代，设置-XX:MaxTenuringThreshold来设置进入老年代的年龄。
4. 动态判断对象年龄，并不一定到了设置的年龄才进入老年代，如果Survivor中相同年龄对象大小加起来大于空间的一半，大于等于这个年龄的对象都会直接进入老年代。
5. 空间分配担保，因为Minor GC分配可能Survivor放不下要放入老年代，所以要检测老年大的空间，如果够存放Survivor移过来的所有对象大小自然是安全的。不够用则检测HandlePromotionFailure来看是否允许担保失败，允许就计算每次从Survivor到老年代对象的平均大小，如果空间还是不够用就进行一次Full GC，这样做避免Full GC过于频繁。
6. Minor GC是新生代回收，Full GC是老年代回收。
