## 一、分布式一致性协议
分布式系统有很多种保证一致性的协议，都有各自的优点和缺点。

### 1. 2PC(Two-Phase Commit)

2PC也就是二阶段提交，这种协议需要引入```协调者(Coordinator)```的概念，它的作用是根据所有其他节点的操作情况来最终决定事务是否成功。顾名思义，2PC会分为下面的两个阶段。

1. 阶段一：准备阶段
   - 协调者发起一个事务提交请求，其它所有节点都会收到这个请求，协调者会等待所有节点的相应。
   - 所有参与的节点都会执行事务操作，记录到事务日志中，并且把事务操作结果发送给协调者。
   - 如果所有参与的节点都相应事务提交成功了，那表示可以执行事务提交，如果有一个节点响应失败或者响应超时，则不能执行事务提交，因此这一阶段也被称为投票阶段。

2. 阶段二：提交阶段

   这一阶段是根据上面阶段一的投票结果来进行后续操作的，分别是执行提交事务和执行回滚事务。

   - 执行提交事务

     - 协调者向所有节点发送事务提交请求
     - 所有节点收到提交请求后会正式提交事务，然后释放锁定的资源
     - 提交完后返回Ack消息给协调者
     - 协调者收到所有节点返回的Ack消息，整个分布式事务算是彻底完成了提交
   - 执行回滚事务
     
     - 协调者向所有节点发送事务回滚请求
     - 所有节点收到回滚请求，利用事务日志回滚事务
     - 回滚完后返回Ack消息给协调者
     - 协调者收到所有节点返回的Ack消息，整个分布式事务算是彻底完成了回滚

3. 2PC协议总结
   
   这是一个强一致性的协议，因为按照这个模式，绝对不可能会出现数据不一致的问题。

   - 优点

     原理简单，实现方便，大部分的数据库都是用2PC协议来实现分布式事务。

   - 缺点

     因为只要有一个失败则全部失败。简单来说就是在第一步骤向所有节点询问是否准备好，如果有一个节点返回否认结果，本次事务中止，如果都准好了则进入第二阶段，询问所有节点是否提交，全部通过则提交事务，否则就中止事务。这种方式的风险在于网络问题可能导致有节点失去通信，收不到协调者的信息，造成所有节点阻塞等待，甚至导致提交失败。

     还有可能因为协调者宕机造成所有集群阻塞。


---

### 2. 3PC(Three-Phase Commit)

3PC也就是三阶段提交，其实就是把二阶段提交中的阶段二拆成了两个步骤，分为了预提交和正式提交。

1. 阶段一：准备阶段
   - 协调者发起一个事务提交请求，其它所有节点都会收到这个请求，协调者会等待所有节点的相应。
   - 所有参与的节点都会判断自身是否能够执行事务，并且返回响应信息给协调者。

2. 阶段二：预提交阶段

   这一阶段是根据上面阶段一的投票结果来进行后续操作的，所有节点都响应通过则执行事务预提交，有节点超时或响应无法提交的则中断事务。

   - 执行预提交

     - 协调者向所有节点发送事务预提交请求，进入预提交状态
     - 所有节点收到预提交请求后会预提交事务，写入事务日志
     - 提交完后返回Ack消息给协调者
     - 协调者收到所有节点返回的Ack消息

   - 中断事务
     
     - 协调者向所有节点发送事务中断请求
     - 所有节点收到中断请求，中断事务

3. 阶段三：提交阶段
   
   这一阶段的操作也是基于阶段二的操作结果，因此会有提交事务和中断事务两种操作，要注意的是如果该阶段协调者出问题了，参与事务的节点等待协调者超时后会直接提交事务。

   - 执行提交事务

     - 协调者向所有节点发送事务提交请求
     - 所有节点收到提交请求后会正式提交事务，然后释放锁定的资源
     - 提交完后返回Ack消息给协调者
     - 协调者收到所有节点返回的Ack消息，整个分布式事务算是彻底完成了提交
   - 中断事务
     
     - 协调者向所有节点发送中断事务请求
     - 所有节点收到中断事务请求，利用事务日志回滚事务，释放资源
     - 回滚完后返回Ack消息给协调者
     - 协调者收到所有节点返回的Ack消息，中断整个事务

4. 3PC协议总结

   3PC是基于2PC的一种升级优化，因为加入了超时机制，为了避免2PC中协调者出问题导致节点锁死的问题。

   - 优点
   
   针对2PC中超时可能导致的阻塞问题引入了解决方案。

   - 缺点

   步骤更加复杂，而且还是无法完全避免网络问题带来的失败。

---

### 3. TCC强一致性方案

TCC 的全称是Try、Confirm、Cancel，指下列三个阶段。这个方案实际上是依靠自己编写一套回滚的代码来做回滚的操作，工作量巨大，几乎不使用这种方案。

- Try阶段

  这个阶段说的是对各个服务的资源做检测以及对资源进行 锁定或者预留。
  
- Confirm阶段

  这个阶段说的是在各个服务中执行实际的操作。
  
- Cancel阶段

  如果任何一个服务的业务方法执行出错，那么这里就需要 进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。


---

### 4. RocketMQ事务

![distributed_lock](https://github.com/nemolpsky/note/raw/master/file/distributed/images/分布式一致性协议1.png)

RocketMQ支持分布式事务，本质上也是基于2PC实现的，整体流程如下图，相当于是你在本地执行一段代码，再发送一个消息给RocketMQ的服务时，这两个步骤可以合为一个事务，即你本地代码成功提交，消息也会成功发送，如果你本地代码失败了那消息最终也不会发送出去。

---

### 5. 本地消息表


![distributed_lock](https://github.com/nemolpsky/note/raw/master/file/distributed/images/分布式一致性协议2.png)

本地消息表和上面的MQ分布式事务很像，最大的区别就是不利用MQ自身的分布式事务，而是依靠本地消息表来实现，只依靠MQ保证通讯的可靠。

上面的图和下面的代码都描述了整个步骤，其实就是调用者在本地数据库新建一张消息表，字段可以有消息内容，发送状态，执行状态等列，利用本地数据库的事务来保证本地代码执行和发送消息是一个事务，消息依靠数据库来持久化，MQ只作为通讯手段，被调用者也是依靠消息来把执行结果告诉调用者，这套方案要简单的多，不过会占用数据库资源。

```
// 调用者
public void A() {
   // 1.执行本地逻辑，入库操作
   // 2.写入消息表
   // 3.发送消息
   // 4.更新发送状态
}

public void B() {
   // 1.接收被调用者消息
   // 2.更新消息状态
}

// 被调用者
public void A() {
   // 1.接收消息
   // 2.执行本地逻辑，入库操作
   // 3.根据本地执行结果发送消息给调用者
}
```

---

### 6. 最大努力通知
![distributed_lock](https://github.com/nemolpsky/note/raw/master/file/distributed/images/分布式一致性协议3.png)

这个方案就很简单，以一种重试的机制通知被调用方，同时提供接口让被调用方核对数据，尽可能的让数据保持一致。三方支付的功能就类似这个方案，调用者调用支付服务，支付服务首先会同步回调，返回结果，如果失败再不断重试异步回调，超过重试次数则放弃通知，但是又提供了查询接口以供通知失败的服务自己来查询核对数据。

