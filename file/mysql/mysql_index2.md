## Mysql索引优化

1. 聚簇索引

   首先要了解的是Mysql是用B+树的数据结构来实现的，而B+树一个节点中是可以存储多个数据的，聚簇索引就是把索引和数据一同放在了叶子节点中，聚簇的意思其实就是索引和数据是放在一起的。

   目前InnoDB引擎中所有的主键都默认是聚簇索引，如果没有主键则隐式定义一个主键来当做聚簇索引

   - 优点

     - 因为索引和数据是放在一起的，所以只要查到了对应索引就可以直接查到对应的数据，因为索引和数据是放在一起的。

   - 缺点

     - 更新的代价很大，因为需要把索引和数据放在一起，所以需要将每个被更新的行移动到新的位置。
     - 页分裂问题，如果节点页满了，就需要分裂成两个页面来存储数据，占用更多的空间。

2. 非聚簇索引

   也称为二级索引，和聚簇索引不同的是，它只保存了行数据的主键值，也就是说每次查询都需要在二级索引中查找到对应的主键值，然后再拿这个主键值查询聚簇索引中对应存放主键索引和数据的节点，做了两次查询，这种二次查询也就是被称为"回表查询"。


3. 覆盖索引

   上面说到了非覆盖索引会造成回表查询，这样肯定会对性能造成影响，所以可以使用一种叫做覆盖索引的方法来优化。

   比如table1表中有一个index1索引，里面包含了key1,key2,key3,key4四个字段，而查询的时候只需要key1,key2两个字段，那么只需要查询的时候指定只查询这两个字段就不会做回表查询，因为在索引中已经拿到了字段值，那么就不需要做回表查询了。

   - 优点

     - 避免了回表查询，提高了查询速度
     - 索引数量一般会比数据数量要少，查询起来也快很多，只查询索引速度肯定会更快
     

4. 最左前缀匹配

   在了解最左前缀匹配前需要先了解一下联合索引的概念，其实就是上面举的例子，一个索引里面包含多个字段，比如table1表中有一个index1索引，里面包含了key1,key2,key3,key4四个字段，这就是一个联合索引。

   而建立一个联合索引(key1,key2,key3,key4)，实际上确实建立了4个索引，分别是(key1)，(key1,key2)，(key1,key2,key3)，(key1,key2,key3,key4)，而每次查询匹配都是从左边开始匹配。

   - 例子

     其实总结一下就是只要查询条件能匹配到上面四个索引就可以，可以忽略排序，如果匹配不上就无法使用这个索引。

     ```
     // 下面这五种查询都可以使用到这个索引
     select * from table1 where key1 = 1;
     select * from table1 where key1 = 1 and key2 = 1;
     select * from table1 where key1 = 1 and key2 = 1 and key3 = 1;
     select * from table1 where key1 = 1 and key2 = 1 and key3 = 1 and key4 = 1;
     select * from table1 where key2 = 1 and key1 = 1;

     // 下面这两种就没办法使用到这种索引了
     select * from table1 where key2 = 1;
     select * from table1 where key2 = 1 and key3 = 1;
     ```

   - 优点

     - 因为最左前缀匹配的原因，建立了一个联合索引相当于建立了多个索引，节省了空间，因为索引也是要占据大量空间的
     - 联合索引包含了多个字段，所以有时候查询索引就可以直接满足要查询的字段了，不需要回表查询了，也就是覆盖索引，大大的提高了效率
     - 如果筛选条件有多个的时候联合索引可以直接在索引中过滤掉大量的数据，效率更好，单个索引过滤的数据量会小很多，后面的条件还要在大量数据中继续过滤，性能很低。

       ```
       // 假如表里面有100W条数据，假设每个条件都可以筛选出10%，一个条件就是10W
       // 如果只有key1有索引，过滤出来的数据量就是10W，再在这10W里面过滤另外两个条件
       // 但是如果是联合索引则是100W * 10% * 10% * 10%，筛选出1000条数据
       select * from table1 where key1=1 and key2=2 and key3=3
       ```

5. 查询优化器

   SQL语句的查询在底层执行的时候是会有不同的执行方案，需要通过优化器选择执行成本最低的方案，所以有时候明明有建立索引但是却不使用。
   
   在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。优化过程大致如下： 
   - 根据搜索条件，找出所有可能使用的索引 
   - 计算全表扫描的代价 
   - 计算使用不同索引执行查询的代价 
   - 对比各种执行方案的代价，找出成本最低的那一个

   
6. 索引下推(Index Condition Pushdown)

   这是在5.6版本新加入的优化，按官方文档的说法是只适合二级索引，也就是非聚簇索引，并且只适合联合索引。

   - 开启和关闭

     ```
     // 查询是开启状态，默认是开启的
     SELECT @@optimizer_switch
     // 开启
     SET optimizer_switch = 'index_condition_pushdown=on';
     // 关闭
     SET optimizer_switch = 'index_condition_pushdown=off';
     ```

   - 用处

     - 不使用索引下推
       - 使用二级索引查找主键
       - 使用主键回表查询数据
       - 在查询到的数据中进行where条件的筛选
     - 使用索引下推
       - 使用二级索引查找主键
       - 先判断索引中是否包含了where条件中的字段，如果包含了就先在索引中过滤
       - 过滤完后再进行回表查询
       - 在查询到的数据中继续筛选剩余的where条件
       

   - 使用

     假设有联合索引(key1,key2)，下列的语句只有key1能够利用到索引，然后再在这个基础上筛选key2 like '%2%'，如果使用Explain来解析会发现Extra那栏显示的是Using index condition，这就表示查询key1索引后还会在回表查询前继续匹配key2 like '%2%'，而如果关闭了索引下推则会显示Using where，验证了上面的原理。

     ```
     select * from table1 where key1 = 1 and key2 like '%2%';
     ```