## 一、并发概念以及Java中的并发实现
并发这个概念从字面意思来理解还是比较简单的，就是同时间有多个任务执行，当然这样说也不是太准确，比如在以前电脑还是用单核处理器的时代，同一时间处理器只会执行一项任务，但是从用户的角度来看，所有软件就是同时运行的，也就是所谓的并发，但是实际上达到这种效果的方法是处理器快速的在各个任务之间切换，只不过切换的速度非常快，以致于用户看起来就是在同时运行多个软件。

不过在多核处理器出现后，不同的核心确实可以同时执行不同的任务，也就是并行执行任务，也就是真正意义上的并发，这也是为啥相同条件下多核处理器更快的缘故。

---

## 二、处理器，寄存器和内存的关系
- 处理器，也就是所谓的CPU，是电脑或服务器中最重要的设备之一，它的任务就是进行高速的运算，但是处理器本身是没有任何的存储能力的，也就是说它只能做一些高速的运算，并不能存储大量的数据。
- 内存则可以存储大量的数据，但是内存的运算速度比处理器慢了很多。
- 寄存器则顾名思义，是用来存储处理器的一些运算数据的，可以理解它为处理器提供了一些存储能力，内存往往就是直接从寄存器中读取处理器的各种运算数据。

之所以要介绍这三者的关系是为了能够更好的理解并发问题产生的原因，在多处理器时代，每个处理器都会有自己的寄存器，而如果所有处理器都在运算内存上的同一份数据的话，很有可能会造成每个处理器的寄存器都有不一样的运算结果，这个时候并发问题就产生了，因此处理器读写的时候也会有要遵循的协议规范来避免这种问题，而Java虚拟机中的内存模型定义的对硬件底层进行的数据访问操作也是基于这些硬件来制定的。

---


## 三、Java内存模型
Java内存模型(Java Memory Model，JMM)是Java虚拟机规范汇定义的一种模型，其目的是为了让所有Java虚拟机都遵循这个规范，以确保Java虚拟机在不同的操作系统上执行同样的代码都会有相同的并发效果，让开发人员不用考虑操作系统的差异性带来的兼容问题。

#### 1. 主内存与工作内存
Java内存模型规定了所有变量都必须存储在主内存中，而每个线程则会创建自己的工作内存，如果该线程使用到了主内存中的变量，则需要把这些变量拷贝一份到自己工作线程中，线程之间不允许互相访问对方的工作线程，也不允许直接操作(读取，赋值等)主内存中的变量。


#### 2. 主内存与工作内存的交互
为了避免并发问题，Java内存模型定义了八种操作来完成主内存与工作内存的数据交互操作，也就是数据的拷贝和同步等等。

- lock (锁定)
  
  作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- Dunlock (解锁)

  作用于主内存的变量，它把一个处于锁定状态的变量释放出来， 释放后的变量才可以被其他线程锁定。

- read (读取)

  作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
  
- load (载入)

  作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中口
  
- use (使用)

  作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
  
- assign (赋值)

  作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
  
- store (存储)

  作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
  
- write (写入)

  作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。


除此之外，Java内存模型还有着一些指令的使用规定，按照这些规定来实现Java虚拟机则可以保证并发安全。

- read和load以及store和write必须成对按顺序出现，但是不要求必须是连续的，中间可以插入其它的指令。
- 不允许read和load， store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
- 不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能在主内存中"诞生"，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行sotre和write操作)。

#### 3. 原子性、可见性和有序性
- 原子性

  通过上述的8种操作指令以及指令的使用限制，可以保证在Java代码中对基本类型数据的读写操作都是原子性的，其中要注意的是long和double类型，虽然在Java内存模型中没有要求这两种类型也要实现原子性的操作，但是常用的虚拟机中基本都实现了这两种类型的原子性，因此我们也不需要额外考虑这两种类型的同步问题。

  如果是想要实现更大范围的原子性操作，则提供了monitorenter和monitorexit两个操作指令，也就是对应了synchronized关键字，执行的时候会在代码块的前后编译成这两个指令。

- 可见性

  可见性也就是说一个线程修改了一个变量后，其它线程也可以得知这个通知，比如volatile修饰过的变量可以保证一个变量被修改后其它线程可以立刻得到最新的变量值，synchronized关键字也可以达到这样的效果，此外final修改的变量也有这样的效果，因为final只要初始化之后就不允许再修改值的内容了，这么来看初始化后所有线程也确实能得到final变量的最新值。

- 有序性

  有序性则是指代码编译之后执行时的顺序也一定是和代码中的执行顺序一样，因为最终编译执行的时候，虚拟机很有可能不会按照代码的实际顺序来执行，有时候会进行一些优化而改变执行顺序，而volatile和synchronized都能保证有序性，volatile是禁止了指令重排序，而synchronized则是保证同一时间内执行代码块的代码只有一个线程。


#### 4. 先行发生原则
上面介绍有序性的时候提到了volatile和synchronized都能保证有序性，但是Java语言中还有着一套先行发生原则来保证有序性，这也是为什么在真实写代码的时候不需要大量使用这两个修饰符也不会有并发问题，就是因为这套规则。

例如下面这个例子，如果A线程先于B线程操作，那么j一定等于1，因为B线程可以观察到A线程中对i的操作，并且中间也没有其它对i的操作，所以可以确定j一定等于1。

而如果试着把C线程放在A、B中间就不一样了，因为有可能在C线程还没执行的时候就获取到了i的值，也就是1，也有可能是C线程执行完之后才获取到，也就是2，这就是有线程安全问题的风险了。

```
// 在A线程中执行
i = 1;
// 在B线程中执行
j = i;
// 在C线程中执行
i = 2;
```

下面这些规则也符合Java内存模型中的先行发生原则，所以这种代码也是不需要考虑线程安全问题的。

- 程序次序规则(Program Order Rule) 

  在一个线程内,按照程序代码顺序,书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序,因为要考虑分支、循环等结构。
- 管程锁定规则(Monitor Lock Rule) 

  一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁,而“后面”是指时间上的先后顺序。
- volatile变量规则(Volatile Variable Rule) 

  对一个volatile变量的写操作先行发生于后面对这个变量的读操作,这里的“后面”同样是指时间上的先后顺序。
- 线程启动规则(Thread Start Rule) 

  Thread对象的start)方法先行发生于此线程的每一个动作。
- 线程终止规则(Thread Termination Rule ) 

  线程中的所有操作都先行发生于对此线程的终止检测,我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
- 线程中断规则(Thread Interruption Rule) 

  对线程interrupt)方法的调用先行发生于被中断线程的代码检测到中断事件的发生,可以通过Thread.interrupted()方法检测到是否有中断发生。
- 对象终结规则(Finalizer Rule) 

  一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize)方法的开始。
- 传递性(Transitivity) 

  如果操作A先行发生于操作B,操作B先行发生于操作C,那就可以得出操作A先行发生于操作C的结论。

---

## 总结：
其实并发问题从硬件层面上就存在了，因此如果从根源上来了解最基本的并发问题产生的原因会更加有助于我们从Java语言层面上来了解并发问题。

Java自身也提供了很多设计和规则来解决并发问题，当然最终也是要映射到对硬件层面的操作。

---

##### 引用：
> 深入理解Java虚拟机（第3版），作者周志明